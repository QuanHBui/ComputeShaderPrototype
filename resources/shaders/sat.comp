#version 430

precision highp float;

#define VERT_COUNT_PER_EDGE 2
#define VERT_COUNT_PER_FACE 4
#define COLLIDER_EDGE_COUNT 12
#define COLLIDER_FACE_COUNT 6
#define COLLIDER_VERT_COUNT 8
#define MAX_CONTACT_POINT_COUNT 16
#define MAX_COLLIDER_COUNT 1024

layout(local_size_x = MAX_COLLIDER_COUNT) in;

// The faces and edges must be pre-defined.

// Define quad faces. Iterate every 4 int's
const int faces[COLLIDER_FACE_COUNT][VERT_COUNT_PER_FACE] =
{
	{ 0, 3, 2, 1 }, // front
	{ 0, 4, 7, 3 }, // left
	{ 4, 5, 6, 7 }, // back
	{ 5, 1, 2, 6 }, // right
	{ 0, 1, 5, 4 }, // top
	{ 3, 7, 6, 2 }  // bottom
};

// Define box edges. Iterate every 2 int's. Direction of each edge is arbitrary.
const int edges[COLLIDER_EDGE_COUNT][VERT_COUNT_PER_EDGE] =
{
	{ 0, 1 }, { 1, 5 }, { 4, 7 },
	{ 0, 3 }, { 2, 6 }, { 7, 6 },
	{ 3, 2 }, { 6, 5 }, { 4, 0 },
	{ 2, 1 }, { 4, 5 }, { 3, 7 }
};

struct BoxCollider
{
	vec4 vertices[COLLIDER_VERT_COUNT];
};

struct Manifold
{
	ivec4 contactBoxIndices[2];
	vec4 contactPoints[MAX_CONTACT_POINT_COUNT]; // The first w stores contact point count.
	vec4 contactNormal; // w stores the penetration depth.
};

struct FaceQuery
{
	int faceIdx;
	float largestDist;
	vec3 faceNormal;
};

struct EdgeQuery
{
	float largestDist;
	vec3 pointsA[2];
	vec3 pointsB[2];
	vec3 edgeDirA;
	vec3 edgeDirB;
	vec3 edgeNormal; // This edge normal points away from edgeA.
};

/*-------------------------- Buffers ------------------------------*/
layout(std430, binding = 0) readonly buffer in_collider_data
{
	BoxCollider boxColliders[];
};

layout(std430, binding = 1) readonly buffer in_collision_pair_data
{
	ivec4 collisionPairs[MAX_COLLIDER_COUNT * 2];
};

// This is the out buffer that we are going to append to
layout(std430, binding = 2) writeonly buffer out_manifolds_data
{
	Manifold manifolds[MAX_COLLIDER_COUNT];
};

layout(binding = 3) uniform atomic_uint nextAvailableIdx;
/*-----------------------------------------------------------------*/

// Yes, when we go to a different work group this will be refilled again.
shared vec3 colliderFaceNormals[MAX_COLLIDER_COUNT][COLLIDER_FACE_COUNT];

// Signed distance of plane to an arbitrary point. Assume plane normal is already normalized.
float getSignedDist(vec3 point, vec3 planePoint, vec3 planeNormal)
{
	return dot(planeNormal, point - planePoint);
}

vec3 getSupport(BoxCollider box, vec3 direction)
{
	float projDist        = 0.0f;
	float largestProjDist = 0.0f;
	vec3 supportPoint     = vec3(0.0f);

	// Iterate through all vertices of box. Dot product each of them with direction vector.
	//  Return the vertex with largest dot product.
	for (int vertIdx = 0; vertIdx < COLLIDER_VERT_COUNT; ++vertIdx)
	{
		projDist = dot(box.vertices[vertIdx].xyz, direction);

		if (projDist > largestProjDist)
		{
			supportPoint    = box.vertices[vertIdx].xyz;
			largestProjDist = projDist;
		}
	}

	return supportPoint;
}

vec3 getFaceNormal(BoxCollider box, int faceIdx)
{
	// Calculate face normal - the vertices should all be CCW winded.
	vec3 a = box.vertices[faces[faceIdx][0]].xyz;
	vec3 b = box.vertices[faces[faceIdx][1]].xyz;
	vec3 c = box.vertices[faces[faceIdx][2]].xyz;

	return normalize(cross(b - a, c - a));
}

// 1 local invocation = 1 collider. We might have an issue when the local size
//  is smaller than the MAX_COLLIDER_COUNT.
void calculateFaceNormals()
{
	uint boxIdx = gl_LocalInvocationID.x;

	for (int faceIdx = 0; faceIdx < COLLIDER_FACE_COUNT; ++faceIdx)
	{
		colliderFaceNormals[boxIdx][faceIdx] = getFaceNormal(boxColliders[boxIdx], faceIdx);
	}
}

void getPlane(int boxIdx, int faceIdx, out vec3 planePoint, out vec3 planeNormal)
{
	planeNormal = colliderFaceNormals[boxIdx][faceIdx];

	// Plane point can be any vertex.
	planePoint = boxColliders[boxIdx].vertices[faces[faceIdx][0]].xyz;
}

FaceQuery queryFaceDirections(int boxAIdx, int boxBIdx)
{
	BoxCollider boxA  = boxColliders[boxAIdx];
	BoxCollider boxB  = boxColliders[boxBIdx];
	float dist        = 0.0f;
	vec3 planePoint   = vec3(0.0f);
	vec3 planeNormal  = vec3(0.0f);
	vec3 supportPoint = vec3(0.0f);
	FaceQuery faceQuery;

	// Initialize
	faceQuery.faceIdx     = -1;
	faceQuery.largestDist = -9999.9f;

	// Each face has 4 vertices
	for (int localFaceIdx = 0; localFaceIdx < COLLIDER_FACE_COUNT; ++localFaceIdx)
	{
		// Expand face of boxA to plane
		getPlane(boxAIdx, localFaceIdx, planePoint, planeNormal);

		// Get support point from boxB
		supportPoint = getSupport(boxB, -planeNormal);

		// Get signed distance from support point to plane
		dist = getSignedDist(supportPoint, planePoint, planeNormal);

		if (dist > faceQuery.largestDist)
		{
			faceQuery.faceIdx     = localFaceIdx;
			faceQuery.largestDist = dist;
		}
	}

	return faceQuery;
}

EdgeQuery queryEdgeDirections(BoxCollider boxA, BoxCollider boxB)
{
	vec3 startA = vec3(0.0f);
	vec3 endA   = vec3(0.0f);
	vec3 startB = vec3(0.0f);
	vec3 endB   = vec3(0.0f);
	vec3 edgeA         = vec3(0.0f);
	vec3 edgeB         = vec3(0.0f);
	vec3 edgeNormal    = vec3(0.0f);
	vec3 supportPointB = vec3(0.0f);
	float localDist    = 0.0f;
	EdgeQuery edgeQuery;

	edgeQuery.largestDist = -9999.9f; // TODO: Might want to standardize min/max extent

	// Somehow we obtain the cross edge. In the case of the box, we can use edge 3 - 5.
	// The point in the middle of the cross edge is the center of the box. If not, it's only
	//  the direction of the box center from the current vertA that we care about.
	vec3 centerA = boxA.vertices[3].xyz + (boxA.vertices[3].xyz - boxA.vertices[5].xyz) * 0.5f;

	for (int edgeIdxA = 0; edgeIdxA < COLLIDER_EDGE_COUNT; ++edgeIdxA)
	{
		startA = boxA.vertices[edges[edgeIdxA][0]].xyz;
		endA   = boxA.vertices[edges[edgeIdxA][1]].xyz;
		edgeA  = startA - endA;

		for (int edgeIdxB = 0; edgeIdxB < COLLIDER_EDGE_COUNT; ++edgeIdxB)
		{
			startB = boxB.vertices[edges[edgeIdxB][0]].xyz;
			endB   = boxB.vertices[edges[edgeIdxB][1]].xyz;
			edgeB  = startB - endB;

			edgeNormal = cross(edgeA, edgeB);

			// Check if the normal is in the wrong direction - compare to the center of box A
			//  If so, flip the normal to make sure it's pointing outward from the box center.
			if (dot(edgeNormal, boxA.vertices[edges[edgeIdxA][0]].xyz - centerA) < 0.0f)
				edgeNormal *= -1.0f;

			// With edgeNormal and a vertex from edgeA, we got a plane. We need to find the
			//  distance from a vertex from edge B to said plane.
			supportPointB = getSupport(boxB, -edgeNormal);
			localDist     = getSignedDist(supportPointB, startA, edgeNormal);

			if (localDist > edgeQuery.largestDist)
			{
				edgeQuery.largestDist = localDist;
				edgeQuery.pointsA     = vec3[2](startA, endA);
				edgeQuery.pointsB     = vec3[2](startB, endB);
				edgeQuery.edgeDirA    = edgeA;
				edgeQuery.edgeDirB    = edgeB;
				edgeQuery.edgeNormal  = edgeNormal;
			}
		}
	}

	return edgeQuery;
}

/**
 * Now for the incident face. To find the most anti-parallel face
 *  we simply iterate through all the faces, compute the dot product
 *  of each face normal with the normal of the reference face. The
 *  face with the smallest dot product is the incident face.
 */
vec3 getIncidentNormal(int incidentBoxIdx, vec3 referenceNormal)
{
	vec3 incidentNormal          = vec3(0.0f);
	vec3 potentialIncidentNormal = vec3(0.0f);
	float smallestDotProduct     = 9999.9f;
	float localDotProduct        = 0.0f;

	for (int faceIdx = 0; faceIdx < COLLIDER_FACE_COUNT; ++faceIdx)
	{
		potentialIncidentNormal = colliderFaceNormals[incidentBoxIdx][faceIdx];
		localDotProduct = dot(potentialIncidentNormal, referenceNormal);

		if (localDotProduct < smallestDotProduct)
		{
			smallestDotProduct = localDotProduct;
			incidentNormal     = potentialIncidentNormal;
		}
	}

	return incidentNormal;
}

/**
 * On a high level, we are clipping the incident face on the other convex hull
 *  against the side planes of the minimizing/reference face.
 *
 * So, we need to:
 *  (1) Identify the reference and incident faces
 *  (2) Use some polygon clipping algorithm to clip (cut off) the incident face
 *        against the planes to the sides of the reference face
 *  (3) Keep only the points/vertices that are below the reference face
 *  (4) "Project" each contact point onto the reference face
 *
 * TODO: some namings might be confusing. In this function, we have 2 different
 *  "faceIdx" for example.
 */
Manifold createFaceContact( FaceQuery faceQueryA, int boxAIdx,
							FaceQuery faceQueryB, int boxBIdx )
{
	// Identify reference face and incident face. The closest face that got passed
	//  into this function will be the reference face, and the most anti-parallel
	//  face on the other box is the incident face.

	vec3 referencePoint  = vec3(0.0f);
	vec3 referenceNormal = vec3(0.0f);
	vec3 incidentNormal  = vec3(0.0f);
	int referenceBoxIdx  = -1;
	int incidentBoxIdx   = -1;

	if (faceQueryA.largestDist < faceQueryB.largestDist)
	{
		// Reference face is from box A. Get normal from said face.
		getPlane(boxAIdx, faceQueryA.faceIdx, referencePoint, referenceNormal);
		referenceBoxIdx = boxAIdx;

		incidentNormal = getIncidentNormal(boxBIdx, referenceNormal);
		incidentBoxIdx = boxBIdx;
	}
	else
	{
		// Reference face is from box B. Get normal.
		getPlane(boxBIdx, faceQueryB.faceIdx, referencePoint, referenceNormal);
		referenceBoxIdx = boxBIdx;

		incidentNormal = getIncidentNormal(boxAIdx, referenceNormal);
		incidentBoxIdx = boxAIdx;
	}

	// At this point, we know the incident and reference faces (more like their
	//  normals). Now we have to clip the incident face against the side planes,
	//  spanned from the side faces of the reference face. Bullet and Box2D engines
	//  define the side faces of the reference face to be the faces that are
	//  adjacent to the reference face. This is a modified Sutherland-Hodgeman
	//  Polygon Clipping Algorithm.

	// In our specific case, any face that is perpendicular to the reference face
	//  is a side face. Clipping the incident face against these side faces
	//  potentially generates a lot of contact points. We only keep all points
	//  below the reference face. We shall further reduce the number of contact
	//  points later.
	BoxCollider incidentBox = boxColliders[incidentBoxIdx];
	vec3 clipPlanePoint     = vec3(0.0f);
	vec3 clipPlaneNormal    = vec3(0.0f);
	vec3 startVert          = vec3(0.0f);
	vec3 endVert            = vec3(0.0f);
	vec3 lerpIntersectPoint = vec3(0.0f);
	int startVertIdx        = -1;
	int endVertIdx          = -1;
	float startSignedDist   = 0.0f;
	float endSignedDist     = 0.0f;
	float lerpRatio         = 0.0f;
	Manifold manifold;
	manifold.contactPoints[0].w = 0.0f; // Initialize the contact point count
	int contactPointCount = 0;

	for (int faceIdx = 0; faceIdx < COLLIDER_FACE_COUNT; ++faceIdx)
	{
		getPlane(referenceBoxIdx, faceIdx, clipPlanePoint, clipPlaneNormal);
		if (dot(referenceNormal, clipPlaneNormal) < 0.0001f)
		{
			startVertIdx = faces[faceIdx][0];
			startVert    = vec3(incidentBox.vertices[startVertIdx]);

			for (int vertIdx = 1; vertIdx < VERT_COUNT_PER_FACE; ++vertIdx)
			{
				if (contactPointCount >= MAX_CONTACT_POINT_COUNT) break;

				endVertIdx = faces[faceIdx][vertIdx];
				endVert = vec3(incidentBox.vertices[endVertIdx]);

				startSignedDist = getSignedDist(startVert, clipPlanePoint, clipPlaneNormal);
				endSignedDist   = getSignedDist(endVert, clipPlanePoint, clipPlaneNormal);

				// If start on the positive side and end on the negative side, keep end and
				//  lerp the intersection.
				if (startSignedDist > 0.0001f && endSignedDist < -0.0001f)
				{
					if (getSignedDist(endVert, referencePoint, referenceNormal) < -0.0001f)
					{
						manifold.contactPoints[contactPointCount++] = vec4(endVert, 0.0f);
					}

					lerpRatio = startSignedDist / (startSignedDist - endSignedDist);
					lerpIntersectPoint = mix(startVert, endVert, lerpRatio);

					if (getSignedDist(lerpIntersectPoint, referencePoint, referenceNormal) < -0.0001f)
					{
						manifold.contactPoints[contactPointCount++] = vec4(lerpIntersectPoint, 0.0f);
					}
				}
				// Else if both start and end on the negative side, keep only the end.
				else if ( startSignedDist < -0.0001f && endSignedDist < -0.0001f
						  && getSignedDist(endVert, referencePoint, referenceNormal) < -0.0001f )
				{
					manifold.contactPoints[contactPointCount++] = vec4(endVert, 0.0f);
				}
				// Else if the start on the negative side and end on the positive side,
				//  lerp the intersection.
				else if (startSignedDist < -0.0001f && endSignedDist > 0.0001f)
				{
					lerpRatio = startSignedDist / (startSignedDist - endSignedDist);
					lerpIntersectPoint = mix(startVert, endVert, lerpRatio);

					if (getSignedDist(lerpIntersectPoint, referencePoint, referenceNormal) < -0.0001f)
					{
						manifold.contactPoints[contactPointCount++] = vec4(lerpIntersectPoint, 0.0f);
					}
				}

				// At this point, if none of the conditions above are met, then both start
				//  and end on the positive side; we keep nothing.

				startVert = endVert;
			}
		}
	}

	return manifold;
}

/**
 * On a high level, this function finds the closest points of 2 line segments (edges are just line segments).
 *  In 3D, lines tend to not intersect, but we can find the 2 closest points (1 on each segment). If
 *  we connect these 2 points, we would have a vector whose length is the shortest distance between 2 segments.
 *
 * There are some degenerate cases that we might have to take care of (2 points might close enough to define
 *  a point rather than a line, etc). But, handling those would introduce branching into the shader code.
 *  I have chosen to ignore those degenerate cases.
 *
 *  @reference: Real Time Collision Detection book by Christer Ericson
 */
Manifold createEdgeContact(EdgeQuery edgeQuery, BoxCollider boxA, BoxCollider boxB)
{
	Manifold manifold;

	float s = 0, t = 0;

	vec3 r = edgeQuery.pointsA[0] - edgeQuery.pointsB[0];
	float squaredLengthEdgeA = dot(edgeQuery.edgeDirA, edgeQuery.edgeDirA); // a
	float squaredLengthEdgeB = dot(edgeQuery.edgeDirB, edgeQuery.edgeDirB); // e
	float f = dot(edgeQuery.edgeDirB, r);

	// Focus on general non-degenerate case
	float c     = dot(edgeQuery.edgeDirA, r);
	float b     = dot(edgeQuery.edgeDirA, edgeQuery.edgeDirB);
	float denom = squaredLengthEdgeA * squaredLengthEdgeB - b * b; // a * e - b * b

	// If the denom is not zero, then the 2 line segments are not parallel, we compute
	//  closest point on edgeA and edgeB, then apply clamping to if needed.
	if (denom != 0.0f)
		s = clamp((b * f) / denom, 0.0f, 1.0f); // Clamp to [0, 1]

	t = (b * s + f) / squaredLengthEdgeB;

	// For t, the clamping is a bit more complicated. We need to recalculate s if t is clamped.
	if (t < 0.0f)
	{
		t = 0.0f;
		s = clamp(-c / squaredLengthEdgeA, 0.0f, 1.0f);
	}
	else if (t > 1.0f)
	{
		t = 1.0f;
		s = clamp((b - c) / squaredLengthEdgeA, 0.0f, 1.0f);
	}

	// TODO: Check for directions of edgeDirA and edgeDirB
	vec3 closestPointA = edgeQuery.pointsA[0] + s * edgeQuery.edgeDirA;
	vec3 closestPointB = edgeQuery.pointsB[0] + t * edgeQuery.edgeDirB;

	// Choose the point in the middle of the two closest points above as the edge contact point
	manifold.contactPoints[0] = vec4(0.5f * (closestPointB + closestPointA), 1.0f);

	// TODO: Set the collider pair in the manifold and the contact normal.

	return manifold;
}

void reduceContactPoints(out Manifold manifold)
{

}

// This function will create and append to the manifold buffer.
// We are trying to find the closest feature that defines the contact type, face-face or edge-edge.
//  If the closest feature is a face-face, then we create a face contact.
//  Else if the closest feature is an edge-edge, then we create an edge contact.
//
// @source: http://media.steampowered.com/apps/valve/2015/DirkGregorius_Contacts.pdf
void separatingAxisTest(uint collisionPairIdx)
{
	int boxAIdx      = collisionPairs[collisionPairIdx].x;
	int boxBIdx      = collisionPairs[collisionPairIdx].y;
	BoxCollider boxA = boxColliders[boxAIdx];
	BoxCollider boxB = boxColliders[boxBIdx];

	FaceQuery faceQueryA = queryFaceDirections(boxAIdx, boxBIdx); // Look at faces of A
	if (faceQueryA.largestDist > 0.0f) return; // We have found a separating axis. No overlap.

	FaceQuery faceQueryB = queryFaceDirections(boxBIdx, boxAIdx); // Look at faces of B
	if (faceQueryB.largestDist > 0.0f) return;

	EdgeQuery edgeQuery = queryEdgeDirections(boxB, boxA); // Look at edges of A and B
	if (edgeQuery.largestDist > 0.0f) return;

	// If we get to here, there's no separating axis, the 2 boxes must overlap.
	// Remember that at this point, largestFaceADist, largestFaceBDist, and edgeLargestDist
	//  are all negative, so whichever is the least negative is the minimum penetration distance.
	// Find the closest feature type
	uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
	Manifold manifold;

	if (faceQueryA.largestDist > edgeQuery.largestDist && faceQueryB.largestDist > edgeQuery.largestDist)
	{
		manifold = createFaceContact(faceQueryA, boxAIdx, faceQueryB, boxBIdx);
	}
	else
	{
		manifold = createEdgeContact(edgeQuery, boxA, boxB);
	}

	reduceContactPoints(manifold);

	manifolds[availableIdx] = manifold;
}

// 1 global invocation = 1 collision pair
void main()
{
	uint collisionPairIdx = gl_GlobalInvocationID.x;

	// Perhaps before the SAT, update the face normals first and put them into a
	//  shared array.
	calculateFaceNormals();

	// Sync
	barrier();
	memoryBarrierShared();

	if (collisionPairs[collisionPairIdx].x >= 0)
	{
		separatingAxisTest(collisionPairIdx);
	}
}
