#version 430

// Properties of the collider should be more configurable
#define VERT_COUNT_PER_EDGE 2
#define VERT_COUNT_PER_FACE 4
#define COLLIDER_EDGE_COUNT 12
#define COLLIDER_FACE_COUNT 6
#define COLLIDER_VERT_COUNT 8
#define MAX_CONTACT_POINT_COUNT 16
#define MAX_COLLIDER_COUNT 1024
#define FLT_MAX 9999.9f
#define EPSILON 0.0001f

layout(local_size_x = MAX_COLLIDER_COUNT) in;

// The faces and edges must be pre-defined.

// Define quad faces. Iterate every 4 int's
const int faces[COLLIDER_FACE_COUNT][VERT_COUNT_PER_FACE] =
{
	{ 0, 3, 2, 1 }, // front
	{ 0, 4, 7, 3 }, // left
	{ 4, 5, 6, 7 }, // back
	{ 5, 1, 2, 6 }, // right
	{ 0, 1, 5, 4 }, // top
	{ 3, 7, 6, 2 }  // bottom
};

// Define box edges. Iterate every 2 int's. Direction of each edge is arbitrary.
const int edges[COLLIDER_EDGE_COUNT][VERT_COUNT_PER_EDGE] =
{
	{ 0, 1 }, { 1, 5 }, { 4, 7 },
	{ 0, 3 }, { 2, 6 }, { 7, 6 },
	{ 3, 2 }, { 6, 5 }, { 4, 0 },
	{ 2, 1 }, { 4, 5 }, { 3, 7 }
};

struct BoxCollider
{
	vec4 vertices[COLLIDER_VERT_COUNT];
};

struct Manifold
{
	ivec4 contactBoxIndicesAndContactCount; // x = refBoxIdx, y = incidentBoxIdx, z = contact count
	vec4 contactPoints[MAX_CONTACT_POINT_COUNT];
	vec4 contactNormal; // w stores the penetration depth.
};

struct Plane
{
	vec3 point;
	vec3 normal;
};

struct FaceQuery
{
	int faceIdx;
	float largestDist;
	vec3 faceNormal;
};

struct EdgeQuery
{
	float largestDist;
	vec3 pointsA[VERT_COUNT_PER_EDGE];
	vec3 pointsB[VERT_COUNT_PER_EDGE];
	vec3 edgeDirA;
	vec3 edgeDirB;
	vec3 edgeNormal; // This edge normal points away from edgeA.
};

/*-------------------------- Buffers ------------------------------*/
layout(std430, binding = 0) readonly buffer in_collider_data
{
	ivec4 colliderMisc;
	BoxCollider boxColliders[];
};

layout(std430, binding = 1) readonly buffer in_collision_pair_data
{
	ivec4 collisionPairMisc;
	ivec4 collisionPairs[2 * MAX_COLLIDER_COUNT];
};

// This is the out buffer that we are going to append to
layout(std430, binding = 2) writeonly buffer out_manifolds_data
{
	ivec4 manifoldMisc;
	Manifold manifolds[MAX_COLLIDER_COUNT];
};

//layout(std430, binding = 3) writeonly buffer experimental_out_buffer
//{
//	// Pay attention to the memory layout (offsets in bytes): [0, 16]
//	ivec4 misc;
//	// [16 - sizeof(ivec4) * MAX_COLLIDER_COUNT] = [16 - 16 + 16 * 1024] = [16, 16,400]
//	ivec4 contactBoxIndicesAndContactCount[MAX_COLLIDER_COUNT]; // x = refBoxIdx, y = incidentBoxIdx, z = contact count
//	// [16,400 - 16,400 + sizeof(vec4) * MAX_CONTACT_POINT_COUNT * MAX_COLLIDER_COUNT] = [16,400 - 278,544]
//	vec4 contactPoints[MAX_COLLIDER_COUNT][MAX_CONTACT_POINT_COUNT];
//	// [278,544 - 278,544 + sizeof(vec4) * MAX_COLLIDER_COUNT] = [278,544 - 294,928]
//	vec4 contactNormal[MAX_COLLIDER_COUNT]; // w stores the penetration depth.
//} experimentalBuffer;
//

layout(binding = 0) uniform atomic_uint nextAvailableIdx;
/*-----------------------------------------------------------------*/

// Signed distance of plane to an arbitrary point. Assume plane normal is already normalized.
float getSignedDist(vec3 point, Plane plane)
{
	return dot(plane.normal, point - plane.point);
}

vec3 projectPointOntoPlane(vec3 point, Plane plane)
{
	return point - getSignedDist(point, plane) * plane.normal;
}

vec3 getSupport(BoxCollider box, vec3 direction)
{
	float projDist        = 0.0f;
	float largestProjDist = -FLT_MAX;
	vec3 supportPoint     = vec3(0.0f);

	// Iterate through all vertices of box. Dot product each of them with direction vector.
	//  Return the vertex with largest dot product.
	for (int vertIdx = 0; vertIdx < COLLIDER_VERT_COUNT; ++vertIdx)
	{
		projDist = dot(box.vertices[vertIdx].xyz, direction);

		if (projDist > largestProjDist)
		{
			supportPoint    = box.vertices[vertIdx].xyz;
			largestProjDist = projDist;
		}
	}

	return supportPoint;
}

vec3 getFaceNormal(BoxCollider box, int faceIdx)
{
	// Calculate face normal - the vertices should all be CCW winded.
	vec3 a = box.vertices[faces[faceIdx][0]].xyz;
	vec3 b = box.vertices[faces[faceIdx][1]].xyz;
	vec3 c = box.vertices[faces[faceIdx][2]].xyz;

	return normalize(cross(b - a, c - a));
}

Plane getPlane(BoxCollider box, int faceIdx)
{
	Plane plane;
	plane.point = box.vertices[faces[faceIdx][0]].xyz; // Plane point can be any vertex.
	plane.normal = getFaceNormal(box, faceIdx);

	return plane;
}

/**
 * Build a plane for each face & find the support point in the opposite normal
 *  direction on the other hull. Once support point is found, the distance
 *  between it and the plane is the separation/penetration for this axis.
 *  Keep track of the largest distance.
 */
FaceQuery queryFaceDirections(BoxCollider boxA, BoxCollider boxB)
{
	float dist        = 0.0f;
	Plane plane;
	vec3 supportPoint = vec3(0.0f);
	FaceQuery faceQuery;

	// Initialize
	faceQuery.faceIdx     = -1;
	faceQuery.largestDist = -FLT_MAX;

	for (int localFaceIdx = 0; localFaceIdx < COLLIDER_FACE_COUNT; ++localFaceIdx)
	{
		// Expand face of boxA to a plane
		plane = getPlane(boxA, localFaceIdx);

		// Get support point from boxB
		supportPoint = getSupport(boxB, -plane.normal);

		// Get signed distance from support point to plane
		dist = getSignedDist(supportPoint, plane);

		uint debugIdx = atomicCounterIncrement(nextAvailableIdx);

		manifolds[debugIdx].contactPoints[0] = vec4(plane.point,  -11.44f);
		manifolds[debugIdx].contactPoints[1] = vec4(plane.normal, -11.44f);
		manifolds[debugIdx].contactPoints[2] = vec4(supportPoint, -11.44f);
		manifolds[debugIdx].contactNormal.x = -11.44f;
		manifolds[debugIdx].contactNormal.y = dist;

		// We have to be aware of the direction here, signed distance can be negative. We
		//  care about the least negative/most positive signed distance.
		if (dist > faceQuery.largestDist)
		{
			faceQuery.faceIdx     = localFaceIdx;
			faceQuery.largestDist = dist;
		}
	}

	return faceQuery;
}

/**
 * We consider all the possible edge pairs. For each edge pair do:
 *  (1) Get the cross product between the two witness edges to get the possible
 *        separating axis
 *  (2) Build a plane through the edge of Hull A with normal of cross product
 *  (3) Ensure a consistent normal orientation pointing away from A
 *  (4) Check the distance between the support point in the opposite normal
 *        direction
 */
EdgeQuery queryEdgeDirections(BoxCollider boxA, BoxCollider boxB)
{
	vec3 startA = vec3(0.0f);
	vec3 endA   = vec3(0.0f);
	vec3 startB = vec3(0.0f);
	vec3 endB   = vec3(0.0f);
	vec3 edgeA         = vec3(0.0f);
	vec3 edgeB         = vec3(0.0f);
	vec3 edgeNormal    = vec3(0.0f);
	vec3 supportPointB = vec3(0.0f);
	float localDist    = 0.0f;
	Plane plane;
	EdgeQuery edgeQuery;

	edgeQuery.largestDist = -FLT_MAX;

	// Somehow we obtain the cross edge. In the case of the box, we can use edge 3 - 5.
	// The point in the middle of the cross edge is the center of the box. If not, it's only
	//  the direction of the box center from the current vertA that we care about.
	vec3 centerA = 0.5f * (boxA.vertices[5].xyz + boxA.vertices[3].xyz);

	for (int edgeIdxA = 0; edgeIdxA < COLLIDER_EDGE_COUNT; ++edgeIdxA)
	{
		startA = boxA.vertices[edges[edgeIdxA][0]].xyz;
		endA   = boxA.vertices[edges[edgeIdxA][1]].xyz;
		edgeA  = endA - startA;

		for (int edgeIdxB = 0; edgeIdxB < COLLIDER_EDGE_COUNT; ++edgeIdxB)
		{
			startB = boxB.vertices[edges[edgeIdxB][0]].xyz;
			endB   = boxB.vertices[edges[edgeIdxB][1]].xyz;
			edgeB  = endB - startB;

			edgeNormal = normalize(cross(edgeA, edgeB));

			// Check if the normal is in the wrong direction - compare to the center of box A
			//  If so, flip the normal to make sure it's pointing outward from the box center.
			if (dot(edgeNormal, startA - centerA) < 0.0f)
				edgeNormal *= -1.0f;

			// With edgeNormal and a vertex from edgeA, we got a plane. We need to find the
			//  distance from a vertex from edge B to said plane.
			plane.point   = startA;
			plane.normal  = edgeNormal;
			supportPointB = getSupport(boxB, -edgeNormal);
			localDist     = getSignedDist(supportPointB, plane);

			if (localDist > edgeQuery.largestDist)
			{
				edgeQuery.largestDist = localDist;
				edgeQuery.pointsA     = vec3[2](startA, endA);
				edgeQuery.pointsB     = vec3[2](startB, endB);
				edgeQuery.edgeDirA    = edgeA;
				edgeQuery.edgeDirB    = edgeB;
				edgeQuery.edgeNormal  = edgeNormal;
			}
		}
	}

	return edgeQuery;
}

/**
 * Now for the incident face. To find the most anti-parallel face
 *  we simply iterate through all the faces, compute the dot product
 *  of each face normal with the normal of the reference face. The
 *  face with the smallest dot product is the incident face.
 */
vec3 getIncidentNormal(BoxCollider incidentBox, vec3 referenceNormal)
{
	vec3 incidentNormal          = vec3(0.0f);
	vec3 potentialIncidentNormal = vec3(0.0f);
	float smallestDotProduct     = FLT_MAX;
	float localDotProduct        = 0.0f;

	for (int faceIdx = 0; faceIdx < COLLIDER_FACE_COUNT; ++faceIdx)
	{
		potentialIncidentNormal = getFaceNormal(incidentBox, faceIdx);
		localDotProduct         = dot(potentialIncidentNormal, referenceNormal);

		if (localDotProduct < smallestDotProduct)
		{
			smallestDotProduct = localDotProduct;
			incidentNormal     = potentialIncidentNormal;
		}
	}

	return incidentNormal;
}

/**
 * On a high level, we are clipping the incident face on the other convex hull
 *  against the side planes of the minimizing/reference face.
 *
 * So, we need to:
 *  (1) Identify the reference and incident faces
 *  (2) Use some polygon clipping algorithm to clip (cut off) the incident face
 *        against the planes to the sides of the reference face
 *  (3) Keep only the points/vertices that are below the reference face
 *  (4) "Project" each contact point onto the reference face
 *
 * TODO: some namings might be confusing. In this function, we have 2 different
 *  "faceIdx" for example.
 */
Manifold createFaceContact( FaceQuery faceQueryA, FaceQuery faceQueryB,
							BoxCollider boxA, BoxCollider boxB,
							int boxAIdx, int boxBIdx )
{
	// Identify reference and incident faces. The closest face that got passed
	//  into this function will be the reference face, and the most anti-parallel
	//  face on the other box is the incident face.

	vec3 incidentNormal = vec3(0.0f);
	int referenceBoxIdx = -1;
	int incidentBoxIdx  = -1;
	float incidentLargestDist = 0.0f;
	Plane referencePlane;
	BoxCollider incidentBox;
	BoxCollider referenceBox;

	if (faceQueryA.largestDist < faceQueryB.largestDist)
	{
		// Reference face is from box A. Get normal from said face.
		referencePlane  = getPlane(boxA, faceQueryA.faceIdx);
		referenceBoxIdx = boxAIdx;
		referenceBox    = boxA;

		incidentNormal      = getIncidentNormal(boxB, referencePlane.normal);
		incidentBoxIdx      = boxBIdx;
		incidentBox         = boxB;
		incidentLargestDist = faceQueryB.largestDist;
	}
	else
	{
		// Reference face is from box B. Get normal.
		referencePlane  = getPlane(boxB, faceQueryB.faceIdx);
		referenceBoxIdx = boxBIdx;
		referenceBox    = boxB;

		incidentNormal      = getIncidentNormal(boxA, referencePlane.normal);
		incidentBoxIdx      = boxAIdx;
		incidentBox         = boxA;
		incidentLargestDist = faceQueryA.largestDist;
	}

	// At this point, we know the incident and reference faces (more like their
	//  normals). Now we have to clip the incident face against the side planes,
	//  spanned from the side faces of the reference face. Bullet and Box2D engines
	//  define the side faces of the reference face to be the faces that are
	//  adjacent to the reference face. This is a modified Sutherland-Hodgeman
	//  Polygon Clipping Algorithm.

	// In our specific case, any face that is perpendicular to the reference face
	//  is a side face. Clipping the incident face against these side faces
	//  potentially generates a lot of contact points. We only keep all points
	//  below the reference face. We shall further reduce the number of contact
	//  points later.
	Plane clipPlane;
	vec3 startVert          = vec3(0.0f);
	vec3 endVert            = vec3(0.0f);
	vec3 lerpIntersectPoint = vec3(0.0f);
	vec3 projPointOntoRefPlane = vec3(0.0f);
	int startVertIdx        = -1;
	int endVertIdx          = -1;
	float startSignedDist   = 0.0f;
	float endSignedDist     = 0.0f;
	float lerpRatio         = 0.0f;
	int contactPointCount   = 0;

	Manifold manifold;

	manifold.contactBoxIndicesAndContactCount = ivec4(0);

	for (int i = 0; i < MAX_CONTACT_POINT_COUNT; ++i)
	{
		manifold.contactPoints[i] = vec4(0.0f);
	}

	manifold.contactNormal = vec4(-2.0f); // TODO: This is a debugging value.

	for (int faceIdx = 0; faceIdx < COLLIDER_FACE_COUNT; ++faceIdx)
	{
		clipPlane = getPlane(referenceBox, faceIdx);
		if (abs(dot(referencePlane.normal, clipPlane.normal)) < EPSILON) // Check if perpendicular
		{
			startVertIdx = faces[faceIdx][0];
			startVert    = vec3(incidentBox.vertices[startVertIdx]);

			for (int vertIdx = 1; vertIdx < VERT_COUNT_PER_FACE; ++vertIdx)
			{
				if (contactPointCount >= MAX_CONTACT_POINT_COUNT) break;

				endVertIdx = faces[faceIdx][vertIdx];
				endVert = vec3(incidentBox.vertices[endVertIdx]);

				startSignedDist = getSignedDist(startVert, clipPlane);
				endSignedDist   = getSignedDist(endVert, clipPlane);

				// If start on the positive side and end on the negative side, keep end and
				//  lerp the intersection.
				if (sign(startSignedDist) == 1.0f && sign(endSignedDist) == -1.0f)
				{
					if (sign(getSignedDist(endVert, referencePlane)) == -1.0f)
					{
						projPointOntoRefPlane = projectPointOntoPlane(endVert, referencePlane);
						manifold.contactPoints[contactPointCount++] = vec4(projPointOntoRefPlane, 0.0f);
					}

					lerpRatio = startSignedDist / (startSignedDist - endSignedDist);
					lerpIntersectPoint = mix(startVert, endVert, lerpRatio);

					if (sign(getSignedDist(lerpIntersectPoint, referencePlane)) == -1.0f)
					{
						projPointOntoRefPlane = projectPointOntoPlane(lerpIntersectPoint, referencePlane);
						manifold.contactPoints[contactPointCount++] = vec4(projPointOntoRefPlane, 0.0f);
					}
				}
				// Else if both start and end on the negative side, keep only the end.
				else if ( sign(startSignedDist) == -1.0f && sign(endSignedDist) == -1.0f
						  && sign(getSignedDist(endVert, referencePlane)) < -1.0f )
				{
					projPointOntoRefPlane = projectPointOntoPlane(endVert, referencePlane);
					manifold.contactPoints[contactPointCount++] = vec4(projPointOntoRefPlane, 0.0f);
				}
				// Else if the start on the negative side and end on the positive side,
				//  lerp the intersection.
				else if (sign(startSignedDist) == -1.0f && sign(endSignedDist) == 1.0f)
				{
					lerpRatio = startSignedDist / (startSignedDist - endSignedDist);
					lerpIntersectPoint = mix(startVert, endVert, lerpRatio);

					if (sign(getSignedDist(lerpIntersectPoint, referencePlane)) == -1.0f)
					{
						projPointOntoRefPlane = projectPointOntoPlane(lerpIntersectPoint, referencePlane);
						manifold.contactPoints[contactPointCount++] = vec4(projPointOntoRefPlane, 0.0f);
					}
				}

				// At this point, if none of the conditions above are met, then both start
				//  and end on the positive side; we keep nothing.

				startVert = endVert;
			}
		}
	}

	// Set reference and incident box indices, contact point count, and contact normal.
	//  The penetration depth is the largestDist of incident face.
	manifold.contactBoxIndicesAndContactCount.x = referenceBoxIdx;
	manifold.contactBoxIndicesAndContactCount.y = incidentBoxIdx;
	manifold.contactBoxIndicesAndContactCount.z = contactPointCount;

	manifold.contactNormal = vec4(referencePlane.normal, incidentLargestDist);

	return manifold;
}

/**
 * On a high level, this function finds the closest points of 2 line segments (edges are just line segments).
 *  In 3D, lines tend to not intersect, but we can find the 2 closest points (1 on each segment). If
 *  we connect these 2 points, we would have a vector whose length is the shortest distance between 2 segments.
 *
 * There are some degenerate cases that we might have to take care of (2 points might close enough to define
 *  a point rather than a line, etc). But, handling those would introduce branching into the shader code.
 *  I have chosen to ignore those degenerate cases.
 *
 *  @reference: Real Time Collision Detection book by Christer Ericson
 */
Manifold createEdgeContact(EdgeQuery edgeQuery, int boxAIdx, int boxBIdx)
{
	Manifold manifold;

	manifold.contactBoxIndicesAndContactCount = ivec4(0);

	for (int i = 0; i < MAX_CONTACT_POINT_COUNT; ++i)
	{
		manifold.contactPoints[i] = vec4(0.0f);
	}

	manifold.contactNormal = vec4(-3.0f); // TODO: This is a debugging value.

	float s = 0, t = 0;

	vec3 r = edgeQuery.pointsA[0] - edgeQuery.pointsB[0];
	float squaredLengthEdgeA = dot(edgeQuery.edgeDirA, edgeQuery.edgeDirA); // a
	float squaredLengthEdgeB = dot(edgeQuery.edgeDirB, edgeQuery.edgeDirB); // e
	float f = dot(edgeQuery.edgeDirB, r);

	// Focus on general non-degenerate case
	float c     = dot(edgeQuery.edgeDirA, r);
	float b     = dot(edgeQuery.edgeDirA, edgeQuery.edgeDirB);
	float denom = squaredLengthEdgeA * squaredLengthEdgeB - b * b; // a * e - b * b

	// If the denom is not zero, then the 2 line segments are not parallel, we compute
	//  closest point on edgeA and edgeB, then apply clamping to if needed.
	if (denom != 0.0f)
		s = clamp((b * f) / denom, 0.0f, 1.0f); // Clamp to [0, 1]

	t = (b * s + f) / squaredLengthEdgeB;

	// For t, the clamping is a bit more complicated. We need to recalculate s if t is clamped.
	if (t < 0.0f)
	{
		t = 0.0f;
		s = clamp(-c / squaredLengthEdgeA, 0.0f, 1.0f);
	}
	else if (t > 1.0f)
	{
		t = 1.0f;
		s = clamp((b - c) / squaredLengthEdgeA, 0.0f, 1.0f);
	}

	vec3 closestPointA = edgeQuery.pointsA[0] + s * edgeQuery.edgeDirA;
	vec3 closestPointB = edgeQuery.pointsB[0] + t * edgeQuery.edgeDirB;

	// Choose the point in the middle of the two closest points above as the edge contact point
	manifold.contactPoints[0] = vec4(0.5f * (closestPointB + closestPointA), 0.0f);

	// Set the collider pair indices, contact count, and the contact normal in the manifold
	manifold.contactBoxIndicesAndContactCount.x = boxAIdx;
	manifold.contactBoxIndicesAndContactCount.y = boxBIdx;
	manifold.contactBoxIndicesAndContactCount.z = 1;
	manifold.contactNormal = vec4(edgeQuery.edgeNormal, edgeQuery.largestDist);

	return manifold;
}

void reduceContactPoints(inout Manifold manifold)
{

}

// This function will create and append to the manifold buffer.
// We are trying to find the closest feature that defines the contact type, face-face or edge-edge.
//  If the closest feature is a face-face, then we create a face contact.
//  Else if the closest feature is an edge-edge, then we create an edge contact.
//
// @source: http://media.steampowered.com/apps/valve/2015/DirkGregorius_Contacts.pdf
void separatingAxisTest(uint collisionPairIdx)
{
	int boxAIdx      = collisionPairs[collisionPairIdx].x;
	int boxBIdx      = collisionPairs[collisionPairIdx].y;
	BoxCollider boxA = boxColliders[boxAIdx];
	BoxCollider boxB = boxColliders[boxBIdx];

	uint debugIdx = atomicCounterIncrement(nextAvailableIdx);

	FaceQuery faceQueryA = queryFaceDirections(boxA, boxB); // Look at faces of A

	manifolds[debugIdx].contactNormal.x = boxA.vertices[0].x;
	manifolds[debugIdx].contactNormal.z = -90.44f;

	if (faceQueryA.largestDist > 0.0f) return; // We have found a separating axis. No overlap.

	FaceQuery faceQueryB = queryFaceDirections(boxB, boxA); // Look at faces of B

//	manifolds[debugIdx].contactNormal.y = faceQueryB.largestDist;
	manifolds[debugIdx].contactNormal.y = -78.55f;

	if (faceQueryB.largestDist > 0.0f) return;

	manifolds[debugIdx].contactNormal.y = faceQueryB.largestDist;

	EdgeQuery edgeQuery = queryEdgeDirections(boxA, boxB); // Look at edges of A and B
	if (edgeQuery.largestDist > 0.0f) return;

	// If we get to here, there's no separating axis, the 2 boxes must overlap.
	// Remember that at this point, largestFaceADist, largestFaceBDist, and edgeLargestDist
	//  are all negative, so whichever is the least negative is the minimum penetration distance.
	// Find the closest feature type
	Manifold manifold;

	if (faceQueryA.largestDist > edgeQuery.largestDist && faceQueryB.largestDist > edgeQuery.largestDist)
	{
		manifold = createFaceContact(faceQueryA, faceQueryB, boxA, boxB, boxAIdx, boxBIdx);
	}
	else
	{
		manifold = createEdgeContact(edgeQuery, boxAIdx, boxBIdx);
	}

	uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
	manifolds[availableIdx] = manifold;
}

// 1 global invocation = 1 collision pair
void main()
{
	uint collisionPairIdx = gl_GlobalInvocationID.x;

	if (collisionPairs[collisionPairIdx].x >= 0)
	{
		separatingAxisTest(collisionPairIdx);
	}
}
