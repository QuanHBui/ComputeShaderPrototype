#version 430 core
#extension GL_ARB_compute_shader : require
#extension GL_ARB_shader_storage_buffer_object : require

precision highp float;

// Minimum work group size is guaranteed to be 1024 for OpenGL
layout(local_size_x = 1024, local_size_y = 1) in;

struct Aabb
{
	vec4 minBound, maxBound;
};

struct CollisionPair
{
	Aabb firstBody, secondBody;
};

// Input Aabb buffer. Should be updated every frame
layout(std430, binding = 2) volatile buffer inputSsbo
{
	Aabb aabbInBuffer[];
};

// Output collision pair buffer. Should be empty every frame
layout(std430, binding = 3) writeonly buffer outputSsbo
{
	CollisionPair collisionPairOutBuffer[];
};

layout(binding = 4) uniform atomic_uint atomCounter;

uniform uint numObjects;

/**
 * @reference: https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection
 * @author: Quan Bui
 * @date: 09/23/2020
 */
bool overlapQuery(Aabb firstAabb, Aabb secondAabb)
{
	// Compare max bound of first body vs min bound of second body and
	//  and vice versa. For all 3 dimensions.
	bool collisionX = firstAabb.maxBound.x >= secondAabb.minBound.x 
					  && secondAabb.maxBound.x >= firstAabb.minBound.x;

	bool collisionY = firstAabb.maxBound.y >= secondAabb.minBound.y 
					  && secondAabb.maxBound.y >= firstAabb.minBound.y;

	bool collisionZ = firstAabb.maxBound.z >= secondAabb.minBound.z 
					  && secondAabb.maxBound.z >= firstAabb.minBound.z;

	return collisionX && collisionY && collisionZ;
}

void main()
{
	uint index = gl_LocalInvocationID.x;
	uint availableIndex = atomicCounter(atomCounter);

	if (index >= numObjects) return;

	for (uint i = 0; i < numObjects; ++i)
	{
		// Don't want to do collision test with itself
		if (index == i) continue;
		
		// If collide, push the pair to out buffer using the atomic counter to get the next available index
		if (overlapQuery(aabbInBuffer[i], aabbInBuffer[index]))
		{
			collisionPairOutBuffer[availableIndex].firstBody = aabbInBuffer[i];
			collisionPairOutBuffer[availableIndex].secondBody = aabbInBuffer[index];

			atomicCounterIncrement(atomCounter);
		}
	}
}