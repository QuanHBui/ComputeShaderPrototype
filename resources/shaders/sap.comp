#version 430
#extension GL_ARB_shader_storage_buffer_object : require

#define MAX_NUM_COLLIDERS 1000u

layout(local_size_x = MAX_NUM_COLLIDERS) in;

layout(std430, binding = 1) volatile buffer in_sorted_data
{
	vec4 minCoords[MAX_NUM_COLLIDERS];
	vec4 maxCoords[MAX_NUM_COLLIDERS];
};

layout(std430, binding = 2) volatile buffer out_collision_pairs_data
{
	ivec4 collisionPairs[2 * MAX_NUM_COLLIDERS];
};

layout(binding = 0) uniform atomic_uint nextAvailableIdx;

shared ivec4 localCollisionPairs[2 * MAX_NUM_COLLIDERS];

uniform uint currNumColliders;

subroutine void sweep(uint i, uint j);

subroutine uniform sweep sweepAxis;

subroutine(sweep)
void sweepX(uint i, uint j)
{
	// Check for collision on the x-axis
	if (minCoords[i].x < maxCoords[j].x && maxCoords[i].x > minCoords[j].x)
	{
		uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
		collisionPairs[availableIdx].x = int(minCoords[i].w); // w comp stores object ID
		collisionPairs[availableIdx].y = int(minCoords[j].w);
	}
}

subroutine(sweep)
void sweepY(uint i, uint j)
{
	// Look through the previous collision pair buffer
	for (int collisionPairIdx = 0; collisionPairIdx < 2 * currNumColliders; ++collisionPairIdx)
	{
		if (((int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].y) ||
			 (int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].y)) &&
			  minCoords[i].y < maxCoords[j].y && maxCoords[i].y > minCoords[j].y)
		{
			uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
			collisionPairs[availableIdx].x = int(minCoords[i].w); // w comp stores object ID
			collisionPairs[availableIdx].y = int(minCoords[j].w);

			break;
		}
	}
}

subroutine(sweep)
void sweepZ(uint i, uint j)
{
	for (int collisionPairIdx = 0; collisionPairIdx < 2 * currNumColliders; ++collisionPairIdx)
	{
		if (((int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].y) ||
			 (int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].y)) &&
			  minCoords[i].z < maxCoords[j].z && maxCoords[i].z > minCoords[j].z)
		{
			uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
			collisionPairs[availableIdx].x = int(minCoords[i].w); // w comp stores object ID
			collisionPairs[availableIdx].y = int(minCoords[j].w);

			break;
		}
	}
}

// void prune()
// {
// 	uint aabbIdx = gl_LocalInvocationID.x;

// 	if (aabbIdx >= currNumColliders) return;

// 	for ( uint collisionPairIdx = 0
// 		; collisionPairIdx < atomicCounter(nextAvailableIdx)
// 		; ++collisionPairIdx )
// 	{
// 		if (minCoords[aabbIdx].w < 1000.0f &&
// 			(collisionPairs[collisionPairIdx].x == minCoords[aabbIdx].w ||
// 			collisionPairs[collisionPairIdx].y == minCoords[aabbIdx].w))
// 		{
// 			minCoords[aabbIdx].w += 1000.0f; // Update the AABB list
// 		}
// 	}
// }

void main()
{
	uint collisionPairIdx = 2 * gl_LocalInvocationID.x;

	// Reset collision pair buffer
	uint collisionPairCycle  = 0u;
	for ( collisionPairCycle = collisionPairIdx
		; collisionPairCycle < collisionPairIdx + 2u
		; ++collisionPairCycle )
	{
		if (collisionPairIdx >= 2 * currNumColliders - 1u) break;

		localCollisionPairs[collisionPairCycle] = collisionPairs[collisionPairCycle];	// TODO: Prob don't need to loop 2000 times every time

		// Reset
		collisionPairs[collisionPairCycle] = ivec4(-5, -5, -5, -5);
	}

	barrier(); //=============================================================

	uint currObjectIdx = gl_LocalInvocationID.x;

	for (uint nextObjectIdx = currObjectIdx + 1u; nextObjectIdx < currNumColliders; ++nextObjectIdx)
		sweepAxis(currObjectIdx, nextObjectIdx); // Collision pair buffer got updated.

	barrier(); //=============================================================

	// prune();
}
