#version 430

#define MAX_NUM_COLLIDERS 1024

precision highp float;

layout(local_size_x = MAX_NUM_COLLIDERS) in;

layout(std430, binding = 1) volatile buffer in_sorted_data
{
	vec4 minCoords[MAX_NUM_COLLIDERS];
	vec4 maxCoords[MAX_NUM_COLLIDERS];
};

layout(std430, binding = 2) volatile buffer out_collision_pairs_data
{
	ivec4 collisionPairMisc;
	ivec4 collisionPairs[2 * MAX_NUM_COLLIDERS];
};

layout(binding = 0) uniform atomic_uint nextAvailableIdx;

shared ivec2 localCollisionPairs[2 * MAX_NUM_COLLIDERS];

uniform uint currNumColliders;

subroutine void sweep(uint i, uint j);

subroutine uniform sweep sweepAxis;

subroutine(sweep)
void sweepX(uint i, uint j)
{
	// Check for collision on the x-axis
	if (minCoords[i].x < maxCoords[j].x && maxCoords[i].x > minCoords[j].x)
	{
		uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
		collisionPairs[availableIdx].x = int(minCoords[i].w); // w comp stores object ID
		collisionPairs[availableIdx].y = int(minCoords[j].w);
	}
}

subroutine(sweep)
void sweepY(uint i, uint j)
{
	// Look through the previous collision pair buffer
	for (int collisionPairIdx = 0; collisionPairIdx < 2 * currNumColliders; ++collisionPairIdx)
	{
		if (((int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].y) ||
			 (int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].y)) &&
			  minCoords[i].y < maxCoords[j].y && maxCoords[i].y > minCoords[j].y)
		{
			uint availableIdx = atomicCounterIncrement(nextAvailableIdx);
			collisionPairs[availableIdx].x = int(minCoords[i].w); // w comp stores object ID
			collisionPairs[availableIdx].y = int(minCoords[j].w);

			break;
		}
	}
}

subroutine(sweep)
void sweepZ(uint i, uint j)
{
	for (int collisionPairIdx = 0; collisionPairIdx < 2 * currNumColliders; ++collisionPairIdx)
	{
		if (((int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].y) ||
			 (int(minCoords[j].w) == localCollisionPairs[collisionPairIdx].x && int(minCoords[i].w) == localCollisionPairs[collisionPairIdx].y)) &&
			  minCoords[i].z < maxCoords[j].z && maxCoords[i].z > minCoords[j].z)
		{
			uint availableIdx = atomicCounterIncrement(nextAvailableIdx);

			// Sort ID for consistency
			if (minCoords[i].w < minCoords[j].w)
			{
				collisionPairs[availableIdx].x = int(minCoords[j].w); // w comp stores object ID
				collisionPairs[availableIdx].y = int(minCoords[i].w);
			}
			else
			{
				collisionPairs[availableIdx].x = int(minCoords[i].w);
				collisionPairs[availableIdx].y = int(minCoords[j].w);
			}

			break;
		}
	}
}

// void prune()
// {
// 	uint aabbIdx = gl_LocalInvocationID.x;

// 	if (aabbIdx >= currNumColliders) return;

// 	for ( uint collisionPairIdx = 0
// 		; collisionPairIdx < atomicCounter(nextAvailableIdx)
// 		; ++collisionPairIdx )
// 	{
// 		if (minCoords[aabbIdx].w < 1000.0f &&
// 			(collisionPairs[collisionPairIdx].x == minCoords[aabbIdx].w ||
// 			collisionPairs[collisionPairIdx].y == minCoords[aabbIdx].w))
// 		{
// 			minCoords[aabbIdx].w += 1000.0f; // Update the AABB list
// 		}
// 	}
// }

void main()
{
	uint collisionPairIdx = 2 * gl_LocalInvocationID.x;

	// Reset collision pair buffer
	for ( uint collisionPairCycle = collisionPairIdx
		; collisionPairCycle < collisionPairIdx + 2u && collisionPairCycle < 2 * MAX_NUM_COLLIDERS
		; ++collisionPairCycle )
	{
		localCollisionPairs[collisionPairCycle] = collisionPairs[collisionPairCycle].xy;

		// Reset
		collisionPairs[collisionPairCycle] = ivec4(-5, -5, -5, -5);
	}

	barrier(); //=============================================================
	memoryBarrierShared();
	memoryBarrier();

	uint currObjectIdx = gl_LocalInvocationID.x;

	// Still loop through pretty much all objects in the world
	for (uint nextObjectIdx = 0u; nextObjectIdx < currNumColliders; ++nextObjectIdx)
	{
		if (nextObjectIdx == currObjectIdx) continue;

		sweepAxis(currObjectIdx, nextObjectIdx); // Collision pair buffer got updated.
	}

	barrier(); //=============================================================

	// prune();
}
